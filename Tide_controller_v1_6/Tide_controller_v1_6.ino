/* Tide_controller_v1.6
  Copyright (C) 2012 Luke Miller
 This version is set up to work on a lead-screw driven rack that has
 a limited travel range. There should be a limit switch at each end 
 of the rack's travel, and the distance between the values for 
 upperPos and lowerPos must be equal to the distance between those 
 limit switches. 
 
 Copyright (C) 2012 Luke Miller
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see http://www.gnu.org/licenses/.
 
 
 This program is designed to calculate the current tide height
 and control a motor that changes the water level in a tank.
 
 Written under v1.0.1 of the Arduino IDE.
 
 The harmonics constants for the tide prediction are taken from 
 the XTide harmonics file. The original harmonics.tcd file is 
 available at 
 http://www.flaterco.com/xtide/files.html
 As with XTide, the predictions generated by this program should
 not be used for navigation, and no accuracy or warranty is given
 or implied for these tide predictions. Hell, the chances are 
 pretty good that the tide predictions generated here are 
 completely wrong.
 
 
 */
//********************************************************************************

// Initial setup
//*******************************
#include <avr/pgmspace.h>    // Needed to store values in PROGMEM
// Header files for talking to real time clock
#include <Wire.h>
#include <RTClib.h>
// Real Time Clock setup
RTC_DS1307 RTC;
unsigned int YearIndx = 0;    // Used to index rows in the Equilarg/Nodefactor arrays
float currHours = 0;          // Elapsed hours since start of year
const int adjustGMT = 8;     // Time zone adjustment to get time in GMT. Make sure this is
// correct for the local standard time of the tide station. 
// No daylight savings time adjustments should be made. 
// 8 = Pacific Standard Time (America/Los_Angeles)

int secs = 0; // Keep track of previous seconds value in main loop
int currMinute; // Keep track of current minute value in main loop
//---------------------------------------------------------------------------------------
/*  Stepper motor notes
 This uses a Big Easy Driver to control a unipolar stepper motor. This
 takes two input wires: a direction wire and step wire. The direction is
 set by pulling the direction pin high or low. A single step is taken by 
 pulling the step pin high. 
 By default, when you leave MS1, MS2, and MS3 high on the Big Easy Driver, the 
 driver defaults to 1/16 microstep mode. If a full step is 1.8° (200 steps
 per revolution), then microstep mode moves 1/16 of that, 
 (1.8° * 1/16 = 0.1125° per step), or 3200 microsteps per full revolution 
 of the motor. 
 
 */
const int stepperDir = 8;  // define stepper direction pin. Connect to 
// Big Easy Driver DIR pin
const int stepperStep = 9; // define stepper step pin. Connect to 
// Big Easy Driver STEP pin.

//*******************************

//----------------------------------------------------------------------------------
/* Initialize harmonic constituent arrays. These each hold 37 values for
   the tide site that was extracted using the R scripts:
   tide_harmonics_parse.R and tide_site_extract_harmonics.R 
   If you wish to make predictions for a different site, it will be necessary to
   replace the Amp and Kappa values with values for your site. 
   These are available from NOAA's http://tidesandcurrent.noaa.gov site.
   Kappa here is referred to as "Phase" on NOAA's site. The order of the
   constituents is shown below in the names. Unfortunately this does not match
   NOAA's order, so you will have to rearrange NOAA's values if you want to 
   put new site values in here by hand.
   The Speed, Equilarg and Nodefactor arrays can all stay the same for any 
   site. 
*/

//-----------------------------------------------------
// Begin pasted section from R script "tide_site_extract_harmonics.R"
// Selected station:  Monterey, Monterey Harbor, California 
// The 'datum' printed here is the difference between mean sea level and 
// mean lower low water for the NOAA station. These two values can be 
// found for NOAA tide reference stations on the tidesandcurrents.noaa.gov
//  site under the datum page for each station.
const float Datum = 2.8281 ; // units in feet
// Harmonic constant names: J1, K1, K2, L2, M1, M2, M3, M4, M6, M8, N2, 2N2, O1, OO1, P1, Q1, 2Q1, R2, S1, S2, S4, S6, T2, LDA2, MU2, NU2, RHO1, MK3, 2MK3, MN4, MS4, 2SM2, MF, MSF, MM, SA, SSA
// These names match the NOAA names, except LDA2 here is LAM2 on NOAA's site
typedef float PROGMEM prog_float_t; // Need to define this type before use
PROGMEM prog_float_t Amp[] = {0.071,1.199,0.121,0.023,0.038,1.616,0,0,0,0,0.368,0.044,0.753,0.036,0.374,0.134,0.016,0.003,0.033,0.428,0,0,0.022,0.011,0.041,0.072,0.026,0,0,0,0,0,0,0,0,0.157,0.09};
PROGMEM prog_float_t Kappa[] = {233.4,219.8,172,220.2,225.9,181.1,0,0,0,0,154.6,123.9,203.4,250.2,215.6,195.1,199.4,180.2,319.1,180.2,0,0,167.8,180.7,114.6,161.1,196.6,0,0,0,0,0,0,0,0,206,283.9};
// Speed is unscaled, stored as the original float values
PROGMEM prog_float_t Speed[] = {15.58544,15.04107,30.08214,29.52848,14.49669,28.9841,43.47616,57.96821,86.95231,115.9364,28.43973,27.89535,13.94304,16.1391,14.95893,13.39866,12.85429,30.04107,15,30,60,90,29.95893,29.45563,27.96821,28.51258,13.47151,44.02517,42.92714,57.42383,58.9841,31.0159,1.098033,1.015896,0.5443747,0.0410686,0.0821373};
PROGMEM prog_float_t Equilarg[10][37] = { 
{174.95,18.51,216.55,157.82,231.31,194.25,291.37,28.5,222.75,57,41.93,249.62,171.62,53.64,349.93,19.3,226.99,176.92,180,0,0,0,3.08,29.59,26.6,178.91,156.28,212.76,9.99,236.18,194.25,165.75,31.01,165.75,152.32,280.07,200.13},
{275.37,17.7,214.57,348.14,159.57,270.19,225.29,180.38,90.58,0.77,16.09,121.98,248.92,333.61,349.19,354.82,100.72,177.65,180,0,0,0,2.35,287.37,178.91,73.02,51.75,287.89,162.69,286.28,270.19,89.81,312.35,89.81,254.1,280.81,201.62},
{0.02,14.86,208.97,182.74,72.78,10.35,195.53,20.71,31.06,41.42,27.53,44.7,353.16,221.23,349.43,10.33,27.51,177.39,180,0,0,0,2.61,198.06,19.83,2.65,345.46,25.21,5.85,37.88,10.35,349.65,204.04,349.65,342.83,280.57,201.15},
{83.38,11.3,202.4,3.66,322.99,110.42,165.63,220.84,331.26,81.68,38.87,327.32,98.58,105.09,349.67,27.03,315.49,177.14,180,0,0,0,2.86,108.65,220.64,292.19,280.36,121.72,209.54,149.29,110.42,249.58,93.25,249.58,71.55,280.33,200.67},
{166.42,7.56,195.61,182.09,211.44,210.46,135.69,60.92,271.39,121.85,50.19,249.92,204.31,348,349.9,44.04,243.77,176.88,180,0,0,0,3.12,19.21,61.44,221.71,215.56,218.02,53.36,260.65,210.46,149.54,341.84,149.54,160.27,280.1,200.19},
{264.33,5.26,191.35,1.96,102.4,286.18,69.27,212.36,138.54,64.72,24.12,122.06,283.91,260.62,349.16,21.85,119.79,177.61,180,0,0,0,2.39,276.77,213.53,115.59,113.32,291.44,207.11,310.3,286.18,73.82,258.36,73.82,262.06,280.84,201.69},
{349.75,2.87,186.44,202.17,42.75,26.41,39.61,52.82,79.23,105.64,35.63,44.85,27.45,150.48,349.4,36.66,45.88,177.35,180,0,0,0,2.65,187.53,54.51,45.29,46.33,29.28,49.95,62.04,26.41,333.59,151.52,333.59,350.78,280.6,201.21},
{76.92,1.58,183.41,39.83,314.62,126.83,10.24,253.65,20.48,147.31,47.32,327.82,129.41,45.42,349.63,49.91,330.4,177.1,180,0,0,0,2.9,98.47,255.68,335.19,337.77,128.41,252.07,174.15,126.83,233.17,48,233.17,79.5,280.37,200.73},
{165.67,1.37,182.52,211.35,206.58,227.47,341.21,94.94,322.41,189.88,59.24,251.02,230.02,304.87,349.87,61.8,253.57,176.84,180,0,0,0,3.16,9.64,97.08,265.3,267.86,228.84,93.57,286.71,227.47,132.53,307.42,132.53,168.23,280.13,200.25},
{269.75,3.07,185.62,17.26,90.25,303.97,275.96,247.95,191.92,135.9,33.96,123.94,304.24,235.22,349.13,34.23,124.21,177.57,180,0,0,0,2.43,267.98,249.95,159.97,160.24,307.04,244.88,337.93,303.97,56.03,235.49,56.03,270.01,280.87,201.75} 
 };

PROGMEM prog_float_t Nodefactor[10][37] = { 
{0.9491,0.9602,0.8878,1.1647,1.1232,1.017,1.0257,1.0343,1.0519,1.0698,1.017,1.017,0.9349,0.7887,1,0.9349,0.9349,1,1,1,1,1,1,1.017,1.017,1.017,0.9349,0.9765,0.9931,1.0343,1.017,1.017,0.8592,1.017,1.0577,1,1},
{0.8928,0.9234,0.8156,1.2048,0.878,1.0272,1.0411,1.0552,1.0839,1.1134,1.0272,1.0272,0.8748,0.6334,1,0.8748,0.8748,1,1,1,1,1,1,1.0272,1.0272,1.0272,0.8748,0.9485,0.9743,1.0552,1.0272,1.0272,0.7448,1.0272,1.0937,1,1},
{0.8492,0.8957,0.768,1.0216,1.3201,1.0344,1.052,1.0699,1.1067,1.1448,1.0344,1.0344,0.829,0.5315,1,0.829,0.829,1,1,1,1,1,1,1.0344,1.0344,1.0344,0.829,0.9265,0.9583,1.0699,1.0344,1.0344,0.6642,1.0344,1.119,1,1},
{0.8278,0.8824,0.7472,0.878,1.5575,1.0377,1.0571,1.0768,1.1173,1.1594,1.0377,1.0377,0.8068,0.4868,1,0.8068,0.8068,1,1,1,1,1,1,1.0377,1.0377,1.0377,0.8068,0.9156,0.9501,1.0768,1.0377,1.0377,0.6271,1.0377,1.1307,1,1},
{0.8343,0.8864,0.7533,0.9704,1.4048,1.0367,1.0556,1.0747,1.1141,1.155,1.0367,1.0367,0.8135,0.5,1,0.8135,0.8135,1,1,1,1,1,1,1.0367,1.0367,1.0367,0.8135,0.9189,0.9526,1.0747,1.0367,1.0367,0.6381,1.0367,1.1272,1,1},
{0.8669,0.9068,0.7865,1.1656,0.9653,1.0315,1.0477,1.0641,1.0977,1.1323,1.0315,1.0315,0.8475,0.5711,1,0.8475,0.8475,1,1,1,1,1,1,1.0315,1.0315,1.0315,0.8475,0.9354,0.965,1.0641,1.0315,1.0315,0.6961,1.0315,1.109,1,1},
{0.9176,0.9394,0.8458,1.204,0.9343,1.0229,1.0345,1.0463,1.0702,1.0947,1.0229,1.0229,0.9011,0.6981,1,0.9011,0.9011,1,1,1,1,1,1,1.0229,1.0229,1.0229,0.9011,0.9609,0.9829,1.0463,1.0229,1.0229,0.7936,1.0229,1.0783,1,1},
{0.9761,0.9782,0.9272,0.9582,1.6115,1.0117,1.0176,1.0235,1.0354,1.0475,1.0117,1.0117,0.9643,0.8745,1,0.9643,0.9643,1,1,1,1,1,1,1.0117,1.0117,1.0117,0.9643,0.9897,1.0012,1.0235,1.0117,1.0117,0.9188,1.0117,1.039,1,1},
{1.0336,1.0176,1.0225,0.7337,1.9813,0.9992,0.9989,0.9985,0.9977,0.9969,0.9992,0.9992,1.0279,1.0859,1,1.0279,1.0279,1,1,1,1,1,1,0.9992,0.9992,0.9992,1.0279,1.0168,1.016,0.9985,0.9992,0.9992,1.0571,0.9992,0.9955,1,1},
{1.0836,1.0529,1.1201,1.0649,1.5936,0.987,0.9805,0.9741,0.9614,0.9489,0.987,0.987,1.085,1.309,1,1.085,1.085,1,1,1,1,1,1,0.987,0.987,0.987,1.085,1.0392,1.0257,0.9741,0.987,0.987,1.1924,0.987,0.953,1,1} 
 };

// Define unix time values for the start of each year.
//                                      2012       2013       2014       2015       2016       2017       2018       2019       2020       2021
PROGMEM prog_uint32_t startSecs[] = {1325376000,1356998400,1388534400,1420070400,1451606400,1483228800,1514764800,1546300800,1577836800,1609459200};

// 1st year of data in the Equilarg/Nodefactor/startSecs arrays.
const unsigned int startYear = 2012;
//------------------------------------------------------------------



// Define some variables that will hold float-converted versions of the constants above
float currAmp;
float currSpeed;
float currNodefactor;
float currEquilarg;
float currKappa;
//-----------------------------------------------------------------------------
float upperPos = 5.3; // Upper limit, located at upperLimitSwitch. Units = ft.
float lowerPos = 2.3; // Lower limit, located at lowerLimitSwitch. Units = ft.
float currPos;  // Current position, within limit switch range.    Units = ft.
float results;  // results holds the output from the tide calc.    Units = ft.
// The value for upperPos is taken to be the "home" position, so when ever the
// upperLimitSwitch is activated, the motor is at exactly the value of upperPos.
// In contrast, the value of lowerPos can be less precise, it is just close to 
// the position of where the lowerLimitSwitch will activate, and is used as a 
// backup check to make sure the motor doesn't exceed its travel limits. The 
// lowerLimitSwitch is the main determinant of when the motor stops downward
// travel. This is mainly to accomodate the use of magnetic switches where the
// precise position of activation is hard to determine without lots of trial 
// and error.

//-----------------------------------------------------------------------------
// Conversion factor, feet per motor step
// Divide desired travel (in ft.) by this value
// to calculate the number of steps that
// must occur.
const float stepConv = 0.000002604;   // Value for 10 tpi lead screw
/*  10 tooth-per-inch lead screw = 0.1 inches per revolution
 0.1 inches per rev / 12" = 0.008333 ft per revolution
 0.008333 ft per rev / 3200 steps per rev = 0.000002604 ft per step
 Assumes a 200 step per rev stepper motor being controlled in 1/16th
 microstepping mode ( = 3200 steps per revolution).
 We're using feet here because the tide prediction routine outputs
 tide height in units of feet. 
 */

float heightDiff;    // Float variable to hold height difference, in ft.                                    
long stepVal = 0;     // Store the number of steps needed
// to achieve the new height
long counts = 0;       // Store the number of steps that have
// gone by so far.

//---------------------------------------------------------------------------
// Define the digital pin numbers for the limit switches. These will be 
// wired to one lead from a magentic reed switch. The 2nd lead from each reed 
// switch will be wired to ground on the Arduino.
const int lowerLimitSwitch = 10;
const int upperLimitSwitch = 11;
// Define digital pin number for the homeButton
// Pressing this button will run the motor until it hits the upper limit switch
const int homeButton = 12; 

//**************************************************************************
// Welcome to the setup loop
void setup(void)
{  
  Wire.begin();
  RTC.begin();
  //--------------------------------------------------
  pinMode(stepperDir, OUTPUT);   // direction pin for Big Easy Driver
  pinMode(stepperStep, OUTPUT);  // step pin for Big Easy driver. One step per rise.
  digitalWrite(stepperDir, LOW);
  digitalWrite(stepperStep, LOW);

  // Set up switches and input button as inputs. 
  pinMode(lowerLimitSwitch, INPUT);
  digitalWrite(lowerLimitSwitch, HIGH);  // turn on internal pull-up resistor
  pinMode(upperLimitSwitch, INPUT);
  digitalWrite(upperLimitSwitch, HIGH);  // turn on internal pull-up resistor
  pinMode(homeButton, INPUT);
  digitalWrite(homeButton, HIGH);        // turn on internal pull-up resistor
  // When using the internal pull-up resistors for the switches above, the
  // default state for the input pin is HIGH (+5V), and goes LOW (0V) when
  // the switch/button connects to ground. Thus, a LOW value indicates that the
  // button or switch has been activated. 


  // For debugging output to serial monitor
  Serial.begin(115200);
  //************************************
  DateTime now = RTC.now();
  currMinute = now.minute(); // Store current minute value
  printTime(now);  // Call printTime function to print date/time to serial
  delay(4000);

  //************************************
  // Spin motor to position slide at the home position (at upperLimitSwitch)
  // The while loop will continue until the upperLimitSwitch is activated 
  // (i.e. driven LOW). 
  Serial.println("Returning to upper limit");
  while (digitalRead(upperLimitSwitch) != LOW) {
    // Set motor direction, HIGH = counterclockwise
    digitalWrite(stepperDir, HIGH);
    // Move stepper a single step
    digitalWrite(stepperStep, HIGH);
    delayMicroseconds(100);
    digitalWrite(stepperStep, LOW);
  }
  currPos = upperPos; // currPos should now equal upperPos
  Serial.print("Current position: ");
  Serial.print(currPos,2);
  Serial.println(" ft.");
  delay(2000);
}  // End of setup loop.

//**************************************************************************
// Welcome to the Main loop
void loop(void)
{
  // Get current time, store in object 'now'
  DateTime now = RTC.now();

  // If it is the start of a new minute, calculate new tide height and
  // adjust motor position
  if (now.minute() != currMinute) {
    // If now.minute doesn't equal currMinute, a new minute has turned
    // over, so it's time to update the tide height. We only want to do
    // this once per minute. 
    currMinute = now.minute();                   // update currMinute

      // Calculate difference between current year and starting year.
    YearIndx = now.year() - startYear;
    // Calculate hours since start of current year. Hours = seconds / 3600
    currHours = (now.unixtime() - pgm_read_dword_near(&startSecs[YearIndx])) / float(3600);
    // Shift currHours to Greenwich Mean Time
    currHours = currHours + adjustGMT;
    Serial.println();
    printTime(now);
    Serial.print("Previous tide ht: ");
    Serial.print(results);
    Serial.println(" ft.");   
    // *****************Calculate current tide height*************
    results = Datum; // initialize results variable, units of feet.
    for (int harms = 0; harms < 37; harms++) {
      currNodefactor = pgm_read_float_near(&Nodefactor[YearIndx][harms]);
      currAmp = pgm_read_float_near(&Amp[harms]);
      currEquilarg = pgm_read_float_near(&Equilarg[YearIndx][harms]);
      currKappa = pgm_read_float_near(&Kappa[harms]);
      currSpeed = pgm_read_float_near(&Speed[harms]);

      // Calculate each component of the overall tide equation 
      // The currHours value is assumed to be in hours from the start of the
      // year, in the Greenwich Mean Time zone, not the local time zone.
      // There is no daylight savings time adjustment here.  
      results = results + (currNodefactor * currAmp * 
        cos( (currSpeed * currHours + currEquilarg - currKappa) * DEG_TO_RAD));
    }
    //******************End of Tide Height calculation*************

    // Calculate height difference between currPos and
    // new tide height. Value may be positive or negative depending on
    // direction of the tide. Positive values mean the water level
    // needs to be raised to meet the new predicted tide level.
    heightDiff = results - currPos;       // Units of feet.
    // Convert heightDiff into number of steps that must pass
    // to achieve the new height. The result is cast as an unsigned 
    // long integer.
    stepVal = (long)(heightDiff / stepConv);
    stepVal = abs(stepVal);  // remove negative sign if present


    //********************************
    // For debugging
    Serial.print("Height diff: ");
    Serial.print(heightDiff, 3);
    Serial.println(" ft.");
    Serial.print("stepVal calc: ");
    Serial.println(stepVal);
    Serial.print("Target height: ");
    Serial.print(results, 3);
    Serial.println(" ft.");
    Serial.println(); // blank line
    //******************************************************************
    // Motor movement section
    // ************** Lower water level to new position ****************
    // If the heightDiff is negative, AND the target level is less than 
    // the upperPos limit, AND the target level is greater than the 
    // lowerPos limit AND the lowerLimitSwitch 
    // hasn't been activated, then the motor can be moved downward. 
    if ( (heightDiff < 0) & (results < upperPos) & 
      (results > lowerPos) & (digitalRead(lowerLimitSwitch) == HIGH) )
    {
      // Set motor direction to move downward
      digitalWrite(stepperDir, LOW);       
      // Run motor the desired number of steps
      for (int steps = 0; steps < stepVal; steps++) {
        digitalWrite(stepperStep, HIGH);
        delayMicroseconds(100);
        digitalWrite(stepperStep, LOW);
        // check lowerLimitSwitch each step, quit if it is activated
        if (digitalRead(lowerLimitSwitch) == LOW) {
          // Calculate how far the motor managed to turn before
          // hitting the lower limit switch, record that as the new
          // currPos value.
          currPos = currPos - (steps * stepConv);
          Serial.println("Hit lower limit switch");
          break;  // break out of for loop
        }
      }
      if (digitalRead(lowerLimitSwitch) == HIGH) {
        // If the lower limit wasn't reached, then the currPos should
        // be equal to the new water level stored in 'results'.
        currPos = results;
      }       
    }
    // ************Raise water level to new position******************
    // If the heightDiff is positive, AND the target level is greater 
    // than the lowerPos limit, AND the target level is less than the 
    // upperPos limit (plus a 0.025ft buffer), AND the upperLimitSwitch 
    // hasn't been activated, then the motor can be moved.
    else if ( (heightDiff > 0) & (results > lowerPos) & 
      (results < (upperPos + 0.025)) & (digitalRead(upperLimitSwitch) == HIGH) )
    {
      // Set motor direction in reverse
      digitalWrite(stepperDir, HIGH);
      // Run motor the desired number of steps
      for (int steps = 0; steps < stepVal; steps++) {
        digitalWrite(stepperStep, HIGH);
        delayMicroseconds(100);
        digitalWrite(stepperStep, LOW);
        // check upperLimitSwitch each step, quit if it is activated
        if (digitalRead(upperLimitSwitch) == LOW) {
          // Since the upper limit switch is the "home" position
          // we assume that the currPos = upperPos when the
          // upperLimitSwitch is activated.
          currPos = upperPos;
          Serial.println("Hit upper limit switch");
          break;  // break out of for loop
        }
      }
      if (digitalRead(upperLimitSwitch) == HIGH) {
        // If the upper limit wasn't reached, then currPos should
        // be equal to the new water level stored in 'results'.
        currPos = results;
      }     
    }
    // End of motor movement section. If the current tide ht is outside
    // either of the travel limits, then there should be no motor 
    // movement, and the currPos value should not be changed. 
    //*******************************************************************
    if (digitalRead(upperLimitSwitch) == LOW) {
      Serial.println("At upper limit switch, no movement");
      Serial.println();
    }
    if (digitalRead(lowerLimitSwitch) == LOW) {
      Serial.println("At lower limit switch, no movement");
      Serial.println();
    }
  }    // End of if (now.minute() != currMinute) statement

  // TODO: implement return-to-home-position routine.

} // End of main loop


//******************************************************
// Function for printing the current date/time to the 
// serial port in a nicely formatted layout.
void printTime(DateTime now) {
  Serial.print(now.year(), DEC);
  Serial.print('/');
  Serial.print(now.month(), DEC);
  Serial.print('/');
  Serial.print(now.day(), DEC);
  Serial.print(' ');
  Serial.print(now.hour(), DEC);
  Serial.print(':');
  if (now.minute() < 10) {
    Serial.print("0");
    Serial.print(now.minute());
  }
  else if (now.minute() >= 10) {
    Serial.print(now.minute());
  }
  Serial.print(':');
  if (now.second() < 10) {
    Serial.print("0");
    Serial.println(now.second());
  }
  else if (now.second() >= 10) {
    Serial.println(now.second());
  }
}
//********************************************************

