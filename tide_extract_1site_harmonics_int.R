# Filename: tide_extract_1site_harmonics_int.R
# Extract harmonics constituents for a single tide station to be used 
# elsewhere. The harmonics Rdata file needs to have been generated by the 
# tide_harmonics_parse.R script already. 
# This version outputs the C code values as integers, all multiplied by a 
# scaling factor.
# So to use the values later, each value should be divided by the scaling factor
# to convert it back to the proper floating point value.
# Author: Luke Miller  May 3, 2012
###############################################################################

# Load the previously-generated harmonics file that contains data for all 637
# reference sites in North America. These are only for tide reference stations 
# maintained by NOAA. NOAA generates predictions for a few thousand other 
# 'subordinate' stations that are not included in this data set. The subordinate
# station predictions are generally made by applying a height offset 
# correction and high/low tide time correction to the predictions from the local
# reference station. If you wish to make predictions for one of these 
# subordinate stations you'll still need to first generate predictions for the 
# local reference station (contained in this data set) and apply your 
# corrections afterwards.
load('Harmonics_20120302.Rdata')

# Specify a search string that will hopefully only return a single station
stationID = 'San Diego, San Diego Bay'
#stationID = 'Monterey Harbor'
#stationID = 'San Francisco'
# Find row index of the desired station in the harms list
stInd = grep(stationID, harms$station)

# We only want to hold on to starting constants for this year (and future years)
# so we'll get the year index for the current year so that we can dump data from
# earlier years
curr.date = as.POSIXlt(Sys.time())
curr.year = curr.date$year + 1900
year.ind = curr.year - harms$startyear + 1

# Specify number of years' worth of starting constants to keep
# More than 4 year's worth of constants starts to fill up the Arduino SRAM, and
# will not allow the program to run correctly.
keep.years = 4

# Extract the useful bits from the harms list, keeping only data for the 
# desired tide station.
# NOAA generally reports 37 harmonic constituents for a tide station on their 
# site. These correspond to the first 37 constants listed in the XTide harmonics
# file, and all of the names match up except LDA2 (called LAM2 by NOAA). So we
# can just keep the first 37 constants instead of all 175 from the XTide file.
# These will give predictions that are well within the variance in tide height
# caused by local day-to-day weather conditions. Note that the order of the 
# named constituents differs between the XTide harmonics file and the NOAA 
# web pages.
harms1 = list(name = harms$name[1:37], 
		speed = harms$speed[1:37],
		startyear = seq(curr.year, (curr.year+keep.years-1)),
		equilarg = harms$equilarg[1:37, year.ind:(year.ind+keep.years-1)],
		nodefactor = harms$nodefactor[1:37, year.ind:(year.ind+keep.years-1)],
		station = harms$station[stInd],
		units = harms$units[stInd],
		longitude = harms$longitude[stInd],
		latitude = harms$latitude[stInd],
		timezone = harms$timezone[stInd],
		tzfile = harms$tzfile[stInd],
		datum = harms$datum[stInd],
		A = harms$A[stInd,1:37],
		kappa = harms$kappa[stInd,1:37])

attr(harms1$equilarg, 'dimnames')[[1]] = harms1$name
attr(harms1$equilarg, 'dimnames')[[2]] = harms1$startyear
attr(harms1$nodefactor, 'dimnames')[[1]] = harms1$name
attr(harms1$nodefactor, 'dimnames')[[2]] = harms1$startyear


#########################################################
# Scale the values so that they can be stored more compactly as integers
# by the Arduino. 
# A unsigned int can store values from 0 to 65535 in 2 bytes
# Any value above 65535 has to be stored as a long (or unsigned long), which is
# stored in 4 bytes by the Arduino, the same space taken by a float. In that 
# case, there is no advantage to converting values to long/unsigned longs vs. 
# just keeping them as floats. 

harms1$equilarg = harms1$equilarg * 100
storage.mode(harms1$equilarg) <- "integer" # convert matrix of values to integer
harms1$nodefactor = harms1$nodefactor * 10000
storage.mode(harms1$nodefactor) = "integer" # convert matrix to integers
harms1$A = as.integer(harms1$A * 1000)
harms1$kappa = as.integer(harms1$kappa * 10)

#harms1$speed = harms1$speed * intScale	# There is no advantage to scaling speed

# Begin sending output to a text file for copying/pasting into the 
# Arduino sketch.
sink(file = 'Tides_Arduino_preamble.txt', type = 'output', split = TRUE,
		append = FALSE)

# The following lines output the harmonic values in a format that 
# is easy to copy and paste into Arduino code. Just run the script, and copy the
# output on the command line to paste it into the Arduino .ino file. 

cat('// Selected station: ', harms1$station,'\n')
# The 'datum' printed here is the difference between mean sea level and mean 
# lower low water for the NOAA station. These two values can be found for NOAA 
# tide reference stations on the tidesandcurrents.noaa.gov site under the datum
# page for each station. 
cat('const float Datum =', harms1$datum, '; // units in feet\n')
cat('// Harmonic constant names: ')
cat(harms1$name, sep = ', ')
cat('\n')
cat("// These names match the NOAA names, except LDA2 here is LAM2 on NOAA's site\n")
cat("// Amp scaled by 1000, divide by 1000 to convert to original float value\n")
cat('const unsigned int Amp[] = {')
cat(harms1$A, sep = ',')
cat('};\n')
cat("// Kappa scaled by 10, , so divide by 10 to convert to original float value\n")
cat('const unsigned int Kappa[] = {')
cat(harms1$kappa, sep = ',')
cat('};\n')
cat("// Speed is unscaled, stored as the original float values\n")
cat('const float Speed[] = {')
cat(harms1$speed, sep = ',')
cat('};\n')

### Code to output each year's starting values as separate arrays
#for (i in 1:ncol(harms1$equilarg)) {
#	cat('const float Equilarg',harms1$startyear[i],'[] = {', sep = '')
#	cat(harms1$equilarg[, i], sep = ',')
#	cat('};\n')
#}
#
#for (i in 1:ncol(harms1$nodefactor)) {
#	cat('const float Nodefactor',harms1$startyear[i],'[] = {', sep = '')
#	cat(harms1$nodefactor[,i], sep = ',')
#	cat('};\n')
#}

## Create code for a 4 year x 37 constituent array
cat('// Equilarg scaled by 100. Divide by 100 to get original value.\n')
cat('const unsigned int Equilarg[4][37] = { \n')
for (i in 1:(ncol(harms1$equilarg)-1)) {
	cat('{')
	cat(harms1$equilarg[, i], sep = ',')
	cat('},\n')
}
cat('{')
cat(harms1$equilarg[ ,ncol(harms1$equilarg)], sep = ',')
cat('} \n };\n')
cat('\n')

cat("// Nodefactor scaled by 10000. Divide by 10000 to get original float value.\n")
cat('const unsigned int Nodefactor[4][37] = { \n')
for (i in 1:(ncol(harms1$nodefactor)-1)) {
	cat('{')
	cat(harms1$nodefactor[, i], sep = ',')
	cat('},\n')
}
cat('{')
cat(harms1$nodefactor[ ,ncol(harms1$nodefactor)], sep = ',')
cat('} \n };\n')
cat('\n')

cat('// The currYear array will be used as a reference for which row of the\n')
cat('// Equilarg and Nodefactor arrays we should be pulling values from.\n')
cat('const int currYear[] = {')
cat(harms1$startyear, sep = ',')
cat('};\n')

# Close the output text file
sink()